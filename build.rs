use std::{fs, io::Write};

use bytemuck::{cast_slice, from_bytes};
use glam::{Vec2, Vec3};
use image::GenericImageView;

const INPUT_DIR: &str = "./assets";
const OUTPUT_DIR: &str = "./src/assets/generated";

const TEXTURES: &[[&str; 2]] = &[
    ["gamercade", "png"],
    ["brickwall", "jpg"],
    ["brickwall_normal", "jpg"],
];

const MESHES: &[[&str; 2]] = &[["BoxVertexColors", "glb"], ["Fox", "glb"], ["Duck", "glb"]];

// For output files
const TEXTURES_EXTENSION: &str = "T";
const VERTICES_EXTENSION: &str = "V";
const INDICES_EXTENSION: &str = "I";
const PARAMETERS_EXTENSION: &str = "P";

struct TextureOutput {
    name: String,
    width: u32,
    height: u32,
    image_data: Vec<u8>,
}

// Writes the bytes of the file
fn write_file(filename: &str, data: &[u8]) {
    let write_path = format!("{OUTPUT_DIR}/{filename}");
    let mut file_out = fs::File::create(write_path).unwrap();
    file_out.write_all(data).unwrap();
}

impl TextureOutput {
    fn to_output(&self) -> String {
        // Write the struct as Rust code
        let filename = format!("{}_{TEXTURES_EXTENSION}", self.name);
        let width = self.width;
        let height = self.height;

        // Write out the bytes of the image
        write_file(&filename, &self.image_data);

        let filename = filename.to_uppercase();

        format!(
            "
    pub const {filename}: &Texture = &Texture {{
        width: {width},
        height: {height},
        data: include_bytes!(\"{filename}\")
    }};\n"
        )
    }
}

struct StaticMeshOutput {
    name: String,
    vertices: Vec<Vec3>,
    indices: Vec<[u32; 3]>,
    parameters: Vec<f32>,
    attribute_count: usize,
}

impl StaticMeshOutput {
    fn to_output(&self) -> String {
        // Write out the bytes of the mesh data
        let verts = format!("{}_{VERTICES_EXTENSION}", self.name);
        let indices = format!("{}_{INDICES_EXTENSION}", self.name);
        let parameters = format!("{}_{PARAMETERS_EXTENSION}", self.name);

        write_file(&verts, cast_slice(&self.vertices));
        write_file(&indices, cast_slice(&self.indices));
        write_file(&parameters, cast_slice(&self.parameters));

        let name = self.name.to_uppercase();

        let p = self.attribute_count;

        format!(
            "
    pub const {name}: &StaticMesh<{p}> = &StaticMesh {{
        vertices: include_bytes!(\"{verts}\"),
        indices: include_bytes!(\"{indices}\"),
        parameters: include_bytes!(\"{parameters}\"),
    }};\n"
        )
    }
}

fn main() {
    let modfile_path = format!("{OUTPUT_DIR}/mod.rs");

    let mut output = String::from("// Autogenerated file from build.rs\n\n");

    output.push_str(&generate_images());
    output.push_str(&generate_meshes());

    let mut output_file = fs::File::create(modfile_path).unwrap();

    output_file
        .write_all(output.as_bytes())
        .expect("Failed to write output file");
}

fn generate_images() -> String {
    let mut out = String::from(
        "pub mod textures {
    use crate::assets::Texture;\n",
    );

    TEXTURES.iter().for_each(|[filename, extension]| {
        // Read in the image file
        let read_path = format!("{INPUT_DIR}/{filename}.{extension}");

        // Convert it to a vec of bytes
        let bytes = fs::read(read_path).unwrap();
        let image = image::load_from_memory(&bytes).unwrap();
        let image_data = image
            .pixels()
            .flat_map(|(_x, _y, pixel)| [pixel.0[0], pixel.0[1], pixel.0[2]])
            .collect::<Vec<u8>>();

        let texture = TextureOutput {
            name: filename.to_string(),
            width: image.width(),
            height: image.height(),
            image_data,
        };

        // Append the output String
        out.push_str(&texture.to_output());
    });

    out.push_str("}\n");

    out
}

// TODO: Write this
fn generate_meshes() -> String {
    let mut out = String::from(
        "pub mod meshes {
    use crate::assets::{StaticMesh, Texture};\n",
    );

    MESHES.iter().for_each(|[filename, extension]| {
        // Read in the image file
        let read_path = format!("{INPUT_DIR}/{filename}.{extension}");

        println!("Importing {filename}...");

        let (document, buffers, images) = gltf::import(read_path).unwrap();

        let blob = &buffers[0].0;
        let mesh = document.meshes().next().unwrap();

        let primitive = mesh.primitives().next().unwrap();

        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut colors = Vec::new();
        let mut uvs = Vec::new();
        let mut normals = Vec::new();
        let mut attribute_count = 0;

        for (kind, attribute) in primitive.attributes() {
            if attribute.view().unwrap().buffer().index() != 0 {
                panic!("wrong buffer index");
            }
            println!("Found {kind:?}: {:?}", attribute.data_type());
            let view = attribute.view().unwrap();
            let start = attribute.offset() + view.offset();
            let count = attribute.count();
            let end = start + (attribute.count() * attribute.size());
            println!("View: ({start}..{end}), {count} items.");
            let view = &blob[start..end];
            let view: &[f32] = cast_slice(view);

            match kind {
                gltf::Semantic::Positions => {
                    for p in view.chunks_exact(3) {
                        positions.push(Vec3::from_slice(p));
                    }
                    println!("Positions found: {}", positions.len());
                }
                gltf::Semantic::Normals => {
                    for n in view.chunks_exact(3) {
                        normals.push(Vec3::from_slice(n))
                    }
                    attribute_count += 3;
                    println!("Normals found: {}", normals.len());
                }
                gltf::Semantic::TexCoords(_) => {
                    for uv in view.chunks_exact(2) {
                        uvs.push(Vec2::from_slice(uv));
                    }
                    attribute_count += 2;
                    println!("UVs found: {}", uvs.len());
                }
                gltf::Semantic::Colors(_) => {
                    for c in view.chunks_exact(3) {
                        colors.push(Vec3::from_slice(c));
                    }
                    attribute_count += 3;
                    println!("Colors found: {}", colors.len());
                }
                _ => continue,
            }
        }

        if let Some(indices_accessor) = primitive.indices() {
            let size = indices_accessor.size();
            let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
            let count = indices_accessor.count();
            let end = start + (count * size);

            println!("Indices size {size}, count: {count}, buffer[{start}..{end}]");

            for index in blob[start..end].chunks_exact(size * 3) {
                let tri = if size == 2 {
                    let a = *from_bytes::<u16>(&index[0..2]) as u32;
                    let b = *from_bytes::<u16>(&index[2..4]) as u32;
                    let c = *from_bytes::<u16>(&index[4..6]) as u32;
                    [a, b, c]
                } else if size == 4 {
                    let a = *from_bytes::<u32>(&index[0..4]) as u32;
                    let b = *from_bytes::<u32>(&index[4..8]) as u32;
                    let c = *from_bytes::<u32>(&index[8..12]) as u32;
                    [a, b, c]
                } else {
                    panic!("Unhandled byte size for mesh: {filename}");
                };
                indices.push(tri)
            }
            println!("Triangles found: {}", indices.len());
        } else {
            for n in (0..positions.len()).step_by(3) {
                let n = n as u32;
                indices.push([n, n + 1, n + 2])
            }
        }

        let mut parameters = Vec::<Vec<f32>>::new();

        positions.iter().enumerate().for_each(|(index, _)| {
            let mut this_vertex_parameters = Vec::new();
            // Colors, UVs, Normals
            if let Some(color) = colors.get(index) {
                this_vertex_parameters.push(color.x);
                this_vertex_parameters.push(color.y);
                this_vertex_parameters.push(color.z);
            }

            if let Some(uv) = uvs.get(index) {
                this_vertex_parameters.push(uv.x);
                this_vertex_parameters.push(uv.y);
            }

            if let Some(normal) = normals.get(index) {
                this_vertex_parameters.push(normal.x);
                this_vertex_parameters.push(normal.y);
                this_vertex_parameters.push(normal.z);
            }

            parameters.push(this_vertex_parameters);
        });

        let parameters = parameters.into_iter().flatten().collect::<Vec<_>>();

        let static_mesh = StaticMeshOutput {
            name: filename.to_string(),
            vertices: positions,
            indices,
            parameters,
            attribute_count,
        };

        let append = static_mesh.to_output();

        // Append the output String
        out.push_str(&append);

        // Import Images from the .glb
        for (index, image) in images.iter().enumerate() {
            let (size, alpha) = match image.format {
                gltf::image::Format::R8G8B8 => (1, false),
                gltf::image::Format::R8G8B8A8 => (1, true),
                gltf::image::Format::R16G16B16 => (2, false),
                gltf::image::Format::R16G16B16A16 => (2, true),
                gltf::image::Format::R32G32B32FLOAT => (4, false),
                gltf::image::Format::R32G32B32A32FLOAT => (4, true),
                // gltf::image::Format::R8 => todo!(),
                // gltf::image::Format::R8G8 => todo!(),
                // gltf::image::Format::R16 => todo!(),
                // gltf::image::Format::R16G16 => todo!(),
                _ => {
                    println!("Unsupported texture format: {:?}", image.format);
                    continue;
                }
            };

            let mut image_data = Vec::with_capacity((image.width * image.height) as usize);

            let chunks = (3 * size) + if alpha { size } else { 0 };

            for pixel in image.pixels.chunks_exact(chunks) {
                let (r, g, b) = match size {
                    1 => (pixel[0], pixel[1], pixel[2]),
                    2 => {
                        let r = *from_bytes::<u16>(&pixel[0..2]) as f32 / u16::MAX as f32;
                        let g = *from_bytes::<u16>(&pixel[2..4]) as f32 / u16::MAX as f32;
                        let b = *from_bytes::<u16>(&pixel[4..6]) as f32 / u16::MAX as f32;

                        let r = (r * u8::MAX as f32) / u8::MAX as f32;
                        let g = (g * u8::MAX as f32) / u8::MAX as f32;
                        let b = (b * u8::MAX as f32) / u8::MAX as f32;

                        (r as u8, g as u8, b as u8)
                    }
                    4 => {
                        let r = *from_bytes::<f32>(&pixel[0..4]) * u8::MAX as f32;
                        let g = *from_bytes::<f32>(&pixel[4..8]) * u8::MAX as f32;
                        let b = *from_bytes::<f32>(&pixel[8..12]) * u8::MAX as f32;

                        (r as u8, g as u8, b as u8)
                    }
                    _ => unreachable!(),
                };

                image_data.push(r);
                image_data.push(g);
                image_data.push(b);
            }

            let texture = TextureOutput {
                name: format!("{filename}_{index}"),
                width: image.width,
                height: image.height,
                image_data,
            };

            out.push_str(&texture.to_output());
        }
    });

    out.push_str("}\n");

    out
}
