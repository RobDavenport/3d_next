use std::{fs, io::Write};

use bytemuck::{cast_slice, from_bytes};
use glam::Vec3;
use gltf::{Glb, Gltf};
use image::GenericImageView;

const INPUT_DIR: &str = "./assets";
const OUTPUT_DIR: &str = "./src/assets/generated";

const TEXTURES: &[[&str; 2]] = &[
    ["gamercade", "png"],
    ["brickwall", "jpg"],
    ["brickwall_normal", "jpg"],
];

const MESHES: &[[&str; 2]] = &[["BoxVertexColors", "glb"]];

fn main() {
    let modfile_path = format!("{OUTPUT_DIR}/mod.rs");

    let mut output = String::from("// Autogenerated file from build.rs\n\n");

    output.push_str(&generate_images());
    output.push_str(&generate_meshes());

    let mut output_file = fs::File::create(modfile_path).unwrap();

    output_file
        .write_all(output.as_bytes())
        .expect("Failed to write output file");
}

fn generate_images() -> String {
    let mut out = String::from(
        "pub mod textures {
    use crate::assets::Texture;\n",
    );

    TEXTURES.iter().for_each(|[filename, extension]| {
        // Read in the image file
        let read_path = format!("{INPUT_DIR}/{filename}.{extension}");

        // Convert it to a vec of bytes
        let bytes = fs::read(read_path).unwrap();
        let image = image::load_from_memory(&bytes).unwrap();
        let image_bytes = image
            .pixels()
            .flat_map(|(_x, _y, pixel)| [pixel.0[0], pixel.0[1], pixel.0[2]])
            .collect::<Vec<u8>>();

        // Write out the bytes of the image
        let write_path = format!("{OUTPUT_DIR}/{filename}");
        let mut file_out = fs::File::create(write_path).unwrap();
        file_out.write_all(&image_bytes).unwrap();

        // Write the struct as Rust code
        let filename = filename.to_uppercase();
        let width = image.width();
        let height = image.height();
        let append = format!(
            "
    pub const {filename}: &Texture = &Texture {{
        width: {width},
        height: {height},
        data: include_bytes!(\"{filename}\")
    }};\n"
        );

        // Append the output String
        out.push_str(&append);
    });

    out.push_str("}\n");

    out
}

// TODO: Write this
fn generate_meshes() -> String {
    let mut out = String::from(
        "pub mod meshes {
        use crate::{graphics::{Mesh, IndexList, VertexList, ParameterData, TriangleIndices}, shaders::VertexParameters};
        use glam::Vec3;\n",
    );

    MESHES.iter().for_each(|[filename, extension]| {
        // Read in the image file
        let read_path = format!("{INPUT_DIR}/{filename}.{extension}");

        let glb = Glb::from_reader(std::fs::File::open(read_path).unwrap()).unwrap();
        let gltf = Gltf::from_slice(&glb.json).unwrap();
        let blob = glb.bin.unwrap();
        let mesh = gltf.meshes().next().unwrap();

        let primitive = mesh.primitives().next().unwrap();
        let indices_accessor = primitive.indices().unwrap();

        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut colors = Vec::new();
        let mut uvs = Vec::new();
        // let mut normals = Vec::new();

        let size = indices_accessor.size();
        let start = indices_accessor.offset() + indices_accessor.view().unwrap().offset();
        let end = start + indices_accessor.count() * size;

        for index in blob[start..end].chunks_exact(size * 3) {
            let tri = if size == 2 {
                let a = *from_bytes::<u16>(&index[0..size]) as usize;
                let b = *from_bytes::<u16>(&index[size..2 * size]) as usize;
                let c = *from_bytes::<u16>(&index[2 * size..3 * size]) as usize;
                [a, b, c]
            } else if size == 4 {
                let a = *from_bytes::<u32>(&index[0..size]) as usize;
                let b = *from_bytes::<u32>(&index[size..2 * size]) as usize;
                let c = *from_bytes::<u32>(&index[2 * size..3 * size]) as usize;
                [a, b, c]
            } else {
                panic!("Unhandled byte size for mesh: {filename}");
            };
            indices.push(tri)
        }

        for (kind, attribute) in primitive.attributes() {
            let view = attribute.view().unwrap();
            let start = attribute.offset() + view.offset();
            let end = start + (attribute.count() * attribute.size());
            let view = &blob[start..end];
            let view: &[f32] = cast_slice(view);

            match kind {
                gltf::Semantic::Positions => {
                    for p in view.chunks_exact(3) {
                        positions.push(Vec3::new(p[0], p[1], p[2]));
                    }
                }
                gltf::Semantic::TexCoords(_) => {
                    for uv in view.chunks_exact(2) {
                        uvs.push([uv[0], uv[1]]);
                    }
                }
                gltf::Semantic::Colors(_) => {
                    for c in view.chunks_exact(3) {
                        colors.push([c[0], c[1], c[2]]);
                    }
                }
                _ => continue,
            }
        }

        let filename = filename.to_uppercase();

        let indices = indices
            .iter()
            .map(|[a, b, c]| format!("TriangleIndices({a}, {b}, {c})"))
            .collect::<Vec<_>>()
            .join(",");

        let positions = positions
            .iter()
            .map(|position| {
                format!(
                    "Vec3::new({:.1}, {:.1}, {:.1})",
                    position.x, position.y, position.z
                )
            })
            .collect::<Vec<_>>()
            .join(",");

        let parameter_data = colors
            .iter()
            .map(|[u, v, w]| format!("VertexParameters([{u:.1}, {v:.1}, {w:.1}])",))
            .collect::<Vec<_>>()
            .join(",");

        let append = format!(
            "pub fn {filename}() -> Mesh<3> {{
                Mesh {{
                    vertices: VertexList(Box::new([{positions}])),
                    indices: IndexList(Box::new([{indices}])),
                    parameters: ParameterData(Box::new([{parameter_data}])),
                }}
            }}
                "
        );

        // Append the output String
        out.push_str(&append);
    });

    out.push_str("}\n");

    out
}
